# SPDX-License-Identifier: GPL-3.0-or-later
"""
Processes the coverage report generated by xcrun xccov on the xcodebuild testing coverage report.
"""

import json
import sys
from pathlib import Path


class Function:
    def __init__(self, coveredLines, executableLines, executionCount, lineCoverage, lineNumber, name):
        self.coveredLines = coveredLines
        self.executableLines = executableLines
        self.executionCount = executionCount
        self.lineCoverage = lineCoverage
        self.lineNumber = lineNumber
        self.name = name


class File:
    def __init__(self, coveredLines, executableLines, functions, lineCoverage, name, path):
        self.coveredLines = coveredLines
        self.executableLines = executableLines
        self.functions = functions
        self.lineCoverage = lineCoverage
        self.name = name
        self.path = path


class Target:
    def __init__(self, buildProductPath, coveredLines, executableLines, files):
        self.buildProductPath = buildProductPath
        self.coveredLines = coveredLines
        self.executableLines = executableLines
        self.files = files


class CoverageReport:
    def __init__(self, coveredLines, executableLines, lineCoverage, targets):
        self.coveredLines = coveredLines
        self.executableLines = executableLines
        self.lineCoverage = lineCoverage
        self.targets = targets


def load_coverage_report(file_path: str):
    """
    Load in the coverage report file using classes for its nested data types.

    Parameters
    ----------
    file_path : str
        The path to the coverage report file.
    """
    try:
        with open(file_path, 'r') as f:
            data = json.load(f)

        return CoverageReport(
            coveredLines=data["coveredLines"],
            executableLines=data["executableLines"],
            lineCoverage=data["lineCoverage"],
            targets=[
                Target(
                    buildProductPath=target["buildProductPath"],
                    coveredLines=target["coveredLines"],
                    executableLines=target["executableLines"],
                    files=[
                        File(
                            coveredLines=file["coveredLines"],
                            executableLines=file["executableLines"],
                            functions=[Function(**func) for func in file["functions"]],
                            lineCoverage=file["lineCoverage"],
                            name=file["name"],
                            path=file["path"]
                        ) for file in target["files"]
                    ]
                ) for target in data["targets"]
            ]
        )

    except Exception as e:
        print(f"Failed to load or decode JSON: {e}")
        return None


def print_coverage_report(report: CoverageReport, threshold: float):
    """
    Print the coverage report on a file by file basis.

    Parameters
    ----------
    report : CoverageReport
        The loaded coverage report in a structured class.

    threshold : float
        The threshold that the coverage has to pass.
    """
    report_dict = {}
    for target in report.targets:
        for file in target.files:
            if "Build/SourcePackages" not in file.path and "/Tests/" not in file.path:
                relative_path = file.path.split("scribe-org/Scribe-iOS")[-1]
                report_dict[relative_path] = {
                    "coveredLines": float(file.coveredLines),
                    "executableLines": float(file.executableLines),
                    "lineCoverage": file.lineCoverage
                }

    max_file_name_length = max((len(name) for name in report_dict), default=0)

    covered_lines_project = 0.0
    executable_lines_project = 0.0

    print(f"\n{'File'.ljust(max_file_name_length)}  Cover")
    print(f"{'-' * max_file_name_length}-------")
    for f, c in sorted(report_dict.items()):
        file_name_padded = f.ljust(max_file_name_length)
        print(f"{file_name_padded}  {c['lineCoverage'] * 100:.0f}%")
        covered_lines_project += c["coveredLines"]
        executable_lines_project += c["executableLines"]

    line_coverage_project = (covered_lines_project / executable_lines_project) * 100

    print(f"{'-' * max_file_name_length}-------")
    print(f"{'Total'.ljust(max_file_name_length)}  {line_coverage_project:.0f}%\n")

    if line_coverage_project >= threshold:
        if threshold > 0:
            print(f"Required test coverage of {threshold}% reached. Total coverage: {line_coverage_project:.2f}%\n")

        sys.exit(0)

    else:
        print(f"\nError: Code coverage did not meet the {threshold}% threshold.\n")
        sys.exit(1)


def main():
    """
    The main function to parse the report and print the results.
    """
    if len(sys.argv) < 2:
        print(f"Usage: {sys.argv[0]} <coverage-json-file> [coverage-threshold]")
        sys.exit(1)

    coverage_json_file = sys.argv[1]
    coverage_threshold = float(sys.argv[2]) if len(sys.argv) == 3 else 0.0

    if report := load_coverage_report(coverage_json_file):
        print_coverage_report(report, coverage_threshold)

    else:
        print("Failed to load the coverage report.")
        sys.exit(1)

if __name__ == "__main__":
    main()
